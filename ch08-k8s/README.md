# 쿠버네티스란?
: 컨테이너 오케스트레이션 도구
- 일반적인 프로그래머가 관리하는 일은 드물다.
- 쿠버네티스는 `여러 대의 컨테이너`가 `여러 대의 물리적 서버`에 걸쳐 실행되는 것을 전제로 한다.
- 번거로운 컨테이너 생성이나 관리의 수고를 덜어주는 도구

# 마스터 노드와 워커 노드
### 마스터노드
: 쿠버네티스는 전체적인 제어를 담당하는 노드(물리적 서버)
- 컨테이너를 직접 실행하지는 않는다.
- 워커 노드에서 실행되는 컨테이너를 관리하는 역할
- 따라서 컨테이너 엔진도 설치되지 않는다.

### 워커노드
: 실제 동작을 담당하는 노드
- 실제 서버에 해당. 컨테이너가 실제 동작하는 서버
- 컨테이너가 동작해야하므로 컨테이너 엔진이 설치되어야 한다.

### 클러스터
: 마스터 노드와 워커 노드로 구성된 일군의 쿠버네티스 시스템을 
- 클러스터는 사람이 개입하지 않아도 마스터 노드에 설정된 내용에 따라 워커 노드가 관리된다.

## 설치
- 쿠버네티스는 컨테이너 엔진과는 별개의 소프트웨어이다.
- 쿠버네티스를 사용하려면 `쿠버네티스 소프트웨어`와 `CNI(Container Network Interface)`를 설치해야한다.
    - 대표적인 CNI 소프트웨어: flannel, Calico, AWS VPC CNI
- `마스터 노드`에는 컨테이너 등의 상태를 관리하기 위해 `etcd`라는 데이터베이스가 설치된다.
    - `etcd`: key-value 스토어 타입의 데이터베이스
- `워커 노드`에는 도커 엔진 같은 `컨테이너 엔진`이 필요하다.
- 마스터 노드를 설정하는 관리자의 컴퓨터에는 `kubectl`을 설치한다.
    - `kubectl`을 설치해야 마스터 노드에 로그인해 초기 설정을 진행하거나 추후 조정이 가능하다.

### 설치해야하는 소프트웨어 정리
||관리자 컴퓨터|마스터노드|워커노드|
|---|---|---|---|
|설치소프트웨어|kubectl|- 쿠버네티스<br>- CNI 소프트웨어<br>- etcd|컨테이너 엔진|

### 마스터 노드 측 컨트롤 플레인(제어판)의 구성
|항목|내용|
|---|---|
|kube-apiserver|외부와 통신하는 프로세스. kubectl로부터 명령을 전달받아 실행한다.|
|kube-controller-manager|컨트롤러를 통합 관리, 실행한다.|
|kube-scheduler|파드를 워커 노드에 할당한다.|
|cloud-controller-manager|클라우드 서비스와 연동해 서비스를 생성한다.|
|etcd|클러스터 관련 정보 전반을 관리하는 데이터베이스|

### 워커 노드의 구성
|항목|내용|
|---|---|
|kube-let|마스터 노드에 있는 kube-scheduler와 연동하며 워커 노드에 파드를 배치하고 실행한다.<br>또, 실행중인 파드의 상태를 정기적으로 모니터링하며 kube-scheduler에 통지한다.|
|kube-proxy|네트워크 통신의 라우팅 메커니즘|

## 쿠버네테스는 항상 바람직한 상태를 유지한다.
- 쿠버네티스는 컨테이너의 수를 바꿀 수 있음과 동시에 모니터링 기능이 있어서 상태를 유지할 수 있다.
    > 도커 컴포즈도 `always`옵션을 설정해 컨테이너를 모니터링하여 수동으로 상태를 유지할 수 있긴 하다.
- 도커 컴포즈와 차이점은 여러 대의 물리적 서버에 걸쳐 시스템을 구성할 수 있다는 점이다.

### 쿠버네티스를 사용하는 시스템에서 컨테이너 삭제
- 쿠버네티스의 기능은 어디까지나 '자동'으로 상태를 유지하는 것이다.
- 컨테이너를 삭제하고 싶다면 삭제 명령어를 입력하는 것이 아니라 `파일에서 수정한다.`
- 물론 컨테이너이므로 도커 명령어를 써서 컨테이너를 직접 삭제할 수 있다.
- 그러나 쿠버네티스는 이를 감지하고 자동으로 사전에 정의한대로 상태를 구성한다.

### etcd의 역할
- 쿠버네티스의 정의 파일(manifest 파일)을 데이터베이스로 관리한다.
- 쿠버네티스가 정의 파일을 읽어 들이면 그 내용은 etcd 에 저장된다.
- 파드는 DB 정보를 근거로 관리된다.
- 만약 정의 파일을 읽어들인 후 커맨드로 직접 컨테이너를 조작한다면, etcd 정보가 일치하지 않게 되므로 철저한 관리가 필요하다.

# 쿠버네티스의 구성과 관련 용어
## 파드는 컨테이너와 볼륨을 함께 묶은 것이다.
- 기본적으로 파드 하나가 컨테이너 하나이지만 컨테이너가 여러 개 인 파드도 있을수 있다.
    - 여러 개의 컨테이너 예시) 주 프로그램의 출력을 한 밤중에 통계처리하는 프로그램처럼 연동되는 관계
- 파드에 포함되는 볼륨은 기본적으로 함께 파드에 포함되는 컨테이너가 정보를 공유하기 위해 사용한다.
- 파드에 볼륨이 없는 경우도 많다.
- 컨테이너 관리의 단위가 파드이기 때문에 컨테이너가 하나뿐이라도 파드로서 다룬다.

## 서비스: 파드 모임의 반장
- 서비스의 역할: 로드 밸런서. 부하 분산장치.
- 쿠버네티스에서 서비스는 여러 개의 파드를 이끄는 반장이라고 생각하면 된다.
- 서비스가 관리하는 파드는 모두 기본적으로 동일한 구성을 갖는다.
- 구성이 다른 파드는 별도의 서비스로 관리한다.
- 파드가 여러 개의 워커 노드에 걸쳐 동장하더라도 이들을 모두 관리한다.
- 각 서비스는 자동적으로 고정된 IP(`cluster IP`)를 부여받는다. 서비스를 명시적으로 삭제하지 않는한 바뀌지 않는다.
- 서비스 내 각각의 파드는 내부 IP를 부여 받는다.
- 서비스가 분배하는 통신은 한 워커 노드 안으로 국한된다.
    - 여러 워커 노드 간 분배는 로드벨런서 또는 `ingress`가 담당한다.
    - `ingress`: HTTP/HTTPS 전용 응용 계층에서 동작하는 reverse proxy. 로드 밸런서 같은 것
    - 로드 밸런서 또는 ingress는 마스터 노드, 워커 노드가 아닌 `별도의 노드`에서 동작하거나 `물리적 전용 하드웨어`이다.

## ReplicaSet: 파드의 수를 관리하는 반장
- 장애 등의 이유로 파드가 종료 됐을 떄, 모자라는 파드를 보충한다.
- 정의 파일에 정의된 파드의 수가 감소하면 그만큼 파드의 수를 실제로 감소 시킨다.
- `replica`: ReplicaSet가 관리하는 동일한 구성의 파드

## 디플로이먼트: 파드의 배포를 관리하는 요소
- 파드가 사용하는 이미지 등 파드에 대한 정보를 갖고 있다.
- 레플리카세트가 반장이라면 드플로이먼트는 반장보다 위에 있는 상사다.

> 파드, 서비스, 디플로이먼트, 레플리카세트 등을 `리소스`라고 한다. 리소스는 50여 종류가 있다.

### 주요 쿠버네티스 리소스
|리소스 이름|내용|
|---|---|
|`pods`|컨테이너와 볼륨을 합친 것|
|podtemplates|배포 시 파드의 형틀 역할|
|replicationcontrollers|레플리케이션을 제어|
|resourcequotas|쿠버네티스 리소스의 사용량 제한을 설정|
|secrets|키 정보를 관리|
|serviceaccounts|리소스를 다루는 사용자를 관리|
|`services`|파드에 요청을 배분|
|daemonsets|워커 노드마다 하나의 파드를 생성|
|`deployments`|파드의 배포를 관리|
|replicasets|파드의 수를 관리|
|statefulsets|파드의 배포를 상태를 유지하며 관리|
|cronjobs|지정된 스케쥴대로 파드를 실행|
|jobs|파드를 한번 실행|


# 서버 한 대로도 쿠버네티스를 사용할 수 있을까?
- 소규모 서비스에서도 설정만 잘하면 파드가 장애 등으로 망가지더라도 자동으로 파드를 생성해 대체하기 때문에 관리가 편해진다.
- 특히, 클라우드 환경에서는 직접 관리할 필요가 ㅇ벗어 이런 장점이 극대화된다.
- 또한 표준화된 컨테이너 실행 환경이기 때문에 시스템 납품에도 적합하다.
    - 시스템을 쿠버네티스에서 동작하는 형태로 만들면 설정 정보를 함께 배포할 수 있기 때문에 설정이 간단하다.

# 쿠버네시트 명령어
```shell
kubectl 커맨드 옵션
```

## 주요 kubectl 커맨드
|커맨드|내용|
|---|---|
|`create`|리소스 생성|
|edit|리소스 편집|
|`delete`|리소스 삭제|
|`get`|리소스 상태 출력|
|`set`|리소스 값을 설정|
|`apply`|리소스의 변경 사항을 반영|
|describe|상세 정보를 확인|
|diff|`바람직한 상태`와 `현재 상태`의 차이를 확인|
|expose|여러 파드에 부하를 분산하는 새로운 서비스 오브젝트르 생성|
|`scale`|레플리카 수를 변경|
|autoscale|자동 스케일링을 적용|
|rollout|롤아웃을 수행|
|exec|컨테이너에서 명령을 실행|
|run|컨테이너에서 명령을 한번 실행|
|attach|컨테이너에 접속|
|cp|컨테이너에 파일을 복사|
|`logs`|컨테이너의 로그를 화면에 출력|
|cluster-info|클러스터의 상세 정보를 화면에 출력|
|top|cpu, 메모리, 스토리지 등 시스템 자원을 확인|

# 실습이 잘되지 않을 때는
- 서비스에 접근이 안된다면 -> 모든 파드를 삭제하고 다시 시도
- provided port is already allocated -> 포트 개방 또는 포트 번호 수정

# 왜 매니페스트 파일에는 IP 주소를 기재하지 않을까?
- 쿠버네티스의 도앚ㄱ은 자신의 조직에 들어온 부하를 관리하는 것과 비슷하다.
- 부하로 들어오는 것은 워커 노드의 신청에 의해 이뤄지는데 이 과정에서 부하의 프로필(IP주소)을 알게 된다.
- 그리고 쿠버네티스는 부하를 구별하지 않는다.
    - 그저 일이 없는 사람에게 일감을 분배하는 식이다.
    - 따라서 특정 IP 주소를 가진 워커 노드를 대상으로 지시를 내릴 일이 없는 것이다.